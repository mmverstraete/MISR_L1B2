FUNCTION map_l1b2, $
   misr_ptr, $
   radrd_ptr, $
   brf_ptr, $
   rdqi_ptr, $
   prefix, $
   N_MASKS = n_masks, $
   SCL_RGB_MIN = scl_rgb_min, $
   SCL_RGB_MAX = scl_rgb_max, $
   SCL_NIR_MIN = scl_nir_min, $
   SCL_NIR_MAX = scl_nir_max, $
   RGB_LOW = rgb_low, $
   RGB_HIGH = rgb_high, $
   PER_BAND = per_band, $
   TEST_ID = test_id, $
   FIRST_LINE = first_line, $
   LAST_LINE = last_line, $
   LOG_IT = log_it, $
   LOG_FOLDER = log_folder, $
   MAP_BRF = map_brf, $
   MAP_QUAL = map_qual, $
   MAP_FOLDER = map_folder, $
   VERBOSE = verbose, $
   DEBUG = debug, $
   EXCPT_COND = excpt_cond

   ;Sec-Doc
   ;  PURPOSE: This function generates maps of MISR L1B2 data products and
   ;  their quality indicators, together with text legends and a log file.
   ;
   ;  ALGORITHM: This function accesses MISR L1B2 Georectified Radiance
   ;  Product (GRP) Terrain-Projected Top of Atmosphere (ToA)
   ;  Bidirectional reflectance factor (Brf) data through the pointers
   ;  misr_ptr, radrd_ptr, brf_ptr, and rdqi_ptr (generated by
   ;  heap_l1b2_block.pro) and saves some or all of the following files
   ;  for the MODE, PATH, ORBIT and BLOCK specified by the pointer
   ;  misr_ptr:
   ;
   ;  *   36 color RDQI maps, one per data channel
   ;
   ;  *   36 legends for the RDQI maps, one for each RDQI map
   ;
   ;  *   36 B&W L1B2 maps (with colorbars), one per data channel
   ;
   ;  *   18 colorbars for the B&W L1B2 maps, 9 for the VIS
   ;      (Blue/Green/Red) and 9 for the NIR data channels
   ;
   ;  *   36 legends for the B&W L1B2 maps, one per data channel
   ;
   ;  *   17 RGB L1B2 maps (without colorbars), two per off-nadir camera
   ;      (see RGB_LOW and RGB_HIGH below) and one for AN
   ;
   ;  *   17 legends for the RGB L1B2 maps, two per off-nadir camera (see
   ;      RGB_LOW and RGB_HIGH below) and one for AN
   ;
   ;  *   1 Log file
   ;
   ;  The selective generation of output maps is controlled by the
   ;  following optional keyword parameters:
   ;
   ;  *   If the optional keyword parameter MAP_BRF is set, maps of the
   ;      bidirectional reflectance at the top of the atmosphere are
   ;      generated, subject to the setting of the following keywords:
   ;
   ;      -   In Global Mode, if the optional keyword parameter RGB_LOW is
   ;          set, the RGB map is effectively generated at the reduced
   ;          spatial resolution of 1100 m (the high-resolution red
   ;          channel is first spatially averaged to 1.1 km), and the
   ;          composite map is upscaled to the full spatial resolution for
   ;          display and comparison purposes.
   ;
   ;      -   In Global Mode, if the optional keyword parameter RGB_HIGH
   ;          is set, the RGB map is effectively generated at an
   ;          intermediate spatial resolution as the green and blue data
   ;          channels are first upscaled to the native spatial resolution
   ;          of 275 m by duplication, and then combined with the full
   ;          resolution red data channel.
   ;
   ;      -   In Local Mode, all maps are generated at the full native
   ;          spatial resolution of the sensor.
   ;
   ;  *   If the optional keyword parameter PER_BAND is set, black and
   ;      white maps of all 36 data Brf channels are generated.
   ;
   ;  *   In addition, the contents of these maps can be adjusted to meet
   ;      specific needs using one or more of the following keywords:
   ;
   ;      -   The optional keyword parameters SCL_RGB_MIN and SCL_RGB_MAX
   ;          control the stretching of the blue, green and red data
   ;          channels onto black and white values for the purpose of
   ;          mapping the Brf, as described below.
   ;
   ;      -   The optional keyword parameters SCL_NIR_MIN and SCL_NIR_MAX
   ;          control the stretching of the Near-Infrared (NIR) data
   ;          channel onto black and white values for the purpose of
   ;          mapping the Brf, as described below.
   ;
   ;  *   If the optional keyword parameter MAP_QUAL is set, maps of the
   ;      quality indicators of the 36 L1B2 data channels are generated.
   ;      In that case, the color coding of these maps is as follows:
   ;
   ;      -   Blue: Good reflectance value (Brf > 0.0 and RDQI = 0).
   ;
   ;      -   Green: Fair reflectance value (Brf > 0.0 and RDQI = 1).
   ;
   ;      -   Orange: Poor reflectance value (Brf ≥ 0.0 and RDQI = 2).
   ;
   ;      -   Red: Unusable reflectance value (unscale radiance flagged
   ;          and RDQI = 3).
   ;
   ;      -   Yellow: Pixel obscured by topography.
   ;
   ;      -   Black: Pixel unobserved by the camera (edge).
   ;
   ;  *   Lastly, this function also optionally creates a log file to
   ;      allow the repeatability and ensure the traceability of these
   ;      outcomes.
   ;
   ;  SYNTAX: rc = map_l1b2(misr_ptr, radrd_ptr, brf_ptr, rdqi_ptr, $
   ;  prefix, N_MASKS = n_masks, $
   ;  SCL_RGB_MIN = scl_rgb_min, SCL_RGB_MAX = scl_rgb_max, $
   ;  SCL_NIR_MIN = scl_nir_min, SCL_NIR_MAX = scl_nir_max, $
   ;  RGB_LOW = rgb_low, RGB_HIGH = rgb_high, PER_BAND = per_band, $
   ;  TEST_ID = test_id, FIRST_LINE = first_line, LAST_LINE = last_line, $
   ;  LOG_IT = log_it, LOG_FOLDER = log_folder, $
   ;  MAP_BRF = map_brf, MAP_QUAL = map_qual, $
   ;  MAP_FOLDER = map_folder, VERBOSE = verbose, $
   ;  DEBUG = debug, EXCPT_COND = excpt_cond)
   ;
   ;  POSITIONAL PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   misr_ptr {POINTER} [I]: The pointer to a STRING array containing
   ;      metadata on the MISR MODE, PATH, ORBIT and BLOCK of the next 3
   ;      pointer arrays.
   ;
   ;  *   radrd_ptr {POINTER array} [I]: The array of 36 pointers to the
   ;      data buffers containing the UINT L1B2 scaled radiance values
   ;      (with the RDQI attached), in the native order (DF to DA).
   ;
   ;  *   brf_ptr {POINTER array} [I]: The array of 36 pointers to the
   ;      data buffers containing the FLOAT L1B2 BRF values, in the native
   ;      order (DF to DA).
   ;
   ;  *   rdqi_ptr {POINTER array} [I]: The array of 36 pointers to the
   ;      data buffers containing the BYTE L1B2 RDQI values, in the native
   ;      order (DF to DA).
   ;
   ;  *   prefix {STRING} [I]: The character string to be inserted in the
   ;      log and map filenames to distinguish outcomes from multiple
   ;      instances of this function (e.g., when mapping L1B2 data before
   ;      and after replacing missing values).
   ;
   ;  KEYWORD PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   N_MASKS = n_masks {INT} [I] (Default value: 0): In the context
   ;      of replacing missing values in MISR L1B2 data products, this
   ;      variable can range within [1, 3], where 1 forces the best fits
   ;      to be computed over the entire BLOCK, deemed to be occupied by
   ;      the same geophysical medium (typically land), 2 forces the best
   ;      fits to be computed separately over land masses and water
   ;      bodies, and 3 forces the best fits to be computed separately
   ;      over clear land masses, clear water bodies and cloud fields.
   ;      Outside of this context, its value should be 0. The only effect
   ;      of this keyword is to modify the names of map files in such a
   ;      way that multiple versions can be saved in the same directory.
   ;
   ;  *   SCL_RGB_MIN = scl_rgb_min {FLOAT} [I] (Default value: 0.0):
   ;      The smallest L1B2 GRP ToA radiance to be mapped in the visible
   ;      (RGB) spectral channels.
   ;
   ;      -   If set to -1.0, the minimum scaling for each of the 3 RGB
   ;          channels will be set to the minimum non-zero value found in
   ;          those channels (actual stretching).
   ;
   ;      -   If set to 0.0 (or not set), the minimum scaling for each of
   ;          the 3 RGB channels will be set to 0.0 (standard stretching).
   ;
   ;      -   If set to a positive value, the minimum scaling for each of
   ;          the 3 RGB channels will be set to the indicated value
   ;          (specified stretching).
   ;
   ;  *   SCL_RGB_MAX = scl_rgb_max {FLOAT} [I] (Default value: 0.35):
   ;      The largest unscaled L1B2 GRP ToA radiance to be mapped in the
   ;      visible (RGB) spectral channels.
   ;
   ;      -   If set to -1.0, the maximum scaling for each of the 3 RGB
   ;          channels will be set to the maximum non-zero value found in
   ;          those channels (actual stretching).
   ;
   ;      -   If set to 0.0 (or not set), the maximum scaling for each of
   ;          the 3 RGB channels will be set to 0.35 (standard
   ;          stretching).
   ;
   ;      -   If set to a positive value, the maximum scaling for each of
   ;          the 3 RGB channels will be set to the indicated value
   ;          (specified stretching).
   ;
   ;  *   SCL_NIR_MIN = scl_nir_min {FLOAT} [I] (Default value: 0.0):
   ;      The smallest unscaled L1B2 GRP ToA radiance to be mapped in the
   ;      NIR spectral channel.
   ;
   ;      -   If set to -1.0, the minimum scaling for the NIR channel will
   ;          be set to the minimum non-zero value found in that channel
   ;          (actual stretching).
   ;
   ;      -   If set to 0.0 (or not set), the minimum scaling for the NIR
   ;          channel will be set to 0.0 (standard stretching).
   ;
   ;      -   If set to a positive value, the minimum scaling for the NIR
   ;          channel will be set to the indicated value (specified
   ;          stretching).
   ;
   ;  *   SCL_NIR_MAX = scl_nir_max {FLOAT} [I] (Default value: 0.50):
   ;      The largest unscaled L1B2 GRP ToA radiance to be mapped in the
   ;      NIR spectral channel.
   ;
   ;      -   If set to -1.0, the maximum scaling for the NIR channel will
   ;          be set to the maximum non-zero value found in that channel
   ;          (actual stretching).
   ;
   ;      -   If set to 0.0 (or not set), the maximum scaling for the NIR
   ;          channel will be set to 0.5 (standard stretching).
   ;
   ;      -   If set to a positive value, the maximum scaling for the NIR
   ;          channel will be set to the indicated value (specified
   ;          stretching).
   ;
   ;  *   RGB_LOW = rgb_low {INTEGER} [I] (Default value: 1): If set (for
   ;      GM data, and for off-nadir pointing cameras only), this keyword
   ;      requests that the RED spectral channel be averaged first to 1.1
   ;      km and that the resulting RGB map be upsized to 275 m by
   ;      replicating pixel values.
   ;
   ;  *   RGB_HIGH = rgb_high {INTEGER} [I] (Default value: 0): If set
   ;      (for GM data, and for off-nadir pointing cameras only), this
   ;      keyword requests that the non-RED spectral channels be upsized
   ;      first to 275 m by replicating pixel values before generating the
   ;      RGB map.
   ;
   ;  *   PER_BAND = per_band {INTEGER} [I] (Default value: 0): If set
   ;      (for all cameras), this keyword requests that data from each of
   ;      the available spectral bands be mapped separately in black and
   ;      white. All maps are generated at the full spatial resolution,
   ;      where the Global Mode fields available only at the low
   ;      resolution are upsized by duplication.
   ;
   ;  *   TEST_ID = test_id {STRING} [I] (Default value: ”): Flag to
   ;      activate (non-empty STRING) or skip (empty STRING) artificially
   ;      introducing missing data in the L1B2 data buffer; if set, this
   ;      keyword is used in output file names to label experiments.
   ;
   ;  *   FIRST_LINE = first_line {INT array of 36 elements} [I] (Default value: 36 elements set to -1):
   ;      The index (between 0 and 127 [for GM data] or 511 [for LM data])
   ;      of the first line to be replaced by missing data, in the
   ;      corresponding cameras and spectral bands. Values outside that
   ;      range are ignored.
   ;
   ;  *   LAST_LINE = last_line {INT array of 36 elements} [I] (Default value: 36 elements set to -1):
   ;      The index (between 0 and 127 [for GM data] or 511 [for LM data])
   ;      of the last line to be replaced by missing data, in the
   ;      corresponding cameras and spectral bands. Values outside that
   ;      range are ignored.
   ;
   ;  *   LOG_IT = log_it {INT} [I] (Default value: 0): Flag to activate
   ;      (1) or skip (0) generating a log file.
   ;
   ;  *   LOG_FOLDER = log_folder {STRING} [I] (Default value: Set by
   ;      function
   ;      set_roots_vers.pro): The directory address of the output folder
   ;      containing the processing log.
   ;
   ;  *   MAP_BRF = map_brf {INT} [I] (Default value: 0): Flag to activate
   ;      (1) or skip (0) generating maps of the L1B2 Brf data product.
   ;
   ;  *   MAP_QUAL = map_qual {INT} [I] (Default value: 0): Flag to
   ;      activate (1) or skip (0) generating maps of the quality
   ;      indicator (RDQI) of the L1B2 radiance data product.
   ;
   ;  *   MAP_FOLDER = map_folder {STRING} [I] (Default value: Set by
   ;      function
   ;      set_roots_vers.pro): The directory address of the output folder
   ;      containing the maps.
   ;
   ;  *   VERBOSE = verbose {INT} [I] (Default value: 0): Flag to enable
   ;      (> 0) or skip (0) outputting messages on the console:
   ;
   ;      -   If verbose > 0, messages inform the user about progress in
   ;          the execution of time-consuming routines, or the location of
   ;          output files (e.g., log, map, plot, etc.);
   ;
   ;      -   If verbose > 1, messages record entering and exiting the
   ;          routine; and
   ;
   ;      -   If verbose > 2, messages provide additional information
   ;          about intermediary results.
   ;
   ;  *   DEBUG = debug {INT} [I] (Default value: 0): Flag to activate (1)
   ;      or skip (0) debugging tests.
   ;
   ;  *   EXCPT_COND = excpt_cond {STRING} [O] (Default value: ”):
   ;      Description of the exception condition if one has been
   ;      encountered, or a null string otherwise.
   ;
   ;  RETURNED VALUE TYPE: INT.
   ;
   ;  OUTCOME:
   ;
   ;  *   If no exception condition has been detected, this function
   ;      returns 0, and the output keyword parameter excpt_cond is set to
   ;      a null string, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided in the call. If all output options are turned on, this
   ;      function generates and saves 197 (181) files in the default or
   ;      the specified output folder for GM (LM) input, distributed as
   ;      follows:
   ;
   ;      -   18 .png files contain the colorbars for L1B2 BRF maps.
   ;
   ;      -   89 (81) files contain the legends of the corresponding maps.
   ;
   ;      -   1 log file reports on the processing and contains
   ;          information on the contents of the L1B2 files.
   ;
   ;      -   36 files contain the RDQI maps.
   ;
   ;      -   53 (45) files contain the BRF maps, for individual channels
   ;          as well as for RGB composites.
   ;
   ;      When LM data are mapped, there are slightly fewer files because
   ;      all data are at the full spatial resolution, so there are only
   ;      81 files and legends.
   ;
   ;  *   If an exception condition has been detected, this function
   ;      returns a non-zero error code, and the output keyword parameter
   ;      excpt_cond contains a message about the exception condition
   ;      encountered, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided. The log file, maps and colorbars may be inexistent,
   ;      incomplete or incorrect.
   ;
   ;  EXCEPTION CONDITIONS:
   ;
   ;  *   Warning 98: The computer has not been recognized by the function
   ;      get_host_info.pro.
   ;
   ;  *   Error 100: One or more positional parameter(s) are missing.
   ;
   ;  *   Error 110: One or more of the input positional parameters
   ;      misr_ptr, radrd_ptr, brf_ptr, or rdqi_ptr is not of type
   ;      POINTER.
   ;
   ;  *   Error 120: One or more of the input positional parameters
   ;      radrd_ptr, brf_ptr, or rdqi_ptr is not an array.
   ;
   ;  *   Error 130: One or more of the input positional parameters
   ;      radrd_ptr, brf_ptr, or rdqi_ptr does not contain 36 elements.
   ;
   ;  *   Error 140: The input positional parameter prefix is not of type
   ;      STRING.
   ;
   ;  *   Error 150: The input positional parameter n_masks is invalid.
   ;
   ;  *   Error 199: An exception condition occurred in
   ;      set_roots_vers.pro.
   ;
   ;  *   Error 200: An exception condition occurred in function
   ;      orbit2date.pro.
   ;
   ;  *   Error 299: The computer is not recognized and at least one of
   ;      the optional input keyword parameters log_folder, map_folder is
   ;      not specified.
   ;
   ;  *   Error 400: The output folder map_fpath is unwritable.
   ;
   ;  *   Error 410: The output folder log_fpath is unwritable.
   ;
   ;  *   Error 500: An exception condition occurred in function
   ;      hr2lr.pro.
   ;
   ;  *   Error 510: An exception condition occurred in function
   ;      lr2hr.pro.
   ;
   ;  *   Error 520: An exception condition occurred in function
   ;      lr2hr.pro.
   ;
   ;  *   Error 530: An exception condition occurred in function
   ;      lr2hr.pro.
   ;
   ;  DEPENDENCIES:
   ;
   ;  *   force_path_sep.pro
   ;
   ;  *   get_host_info.pro
   ;
   ;  *   hr2lr.pro
   ;
   ;  *   is_array.pro
   ;
   ;  *   is_numeric.pro
   ;
   ;  *   is_pointer.pro
   ;
   ;  *   is_string.pro
   ;
   ;  *   is_writable_dir.pro
   ;
   ;  *   lr2hr.pro
   ;
   ;  *   orbit2date.pro
   ;
   ;  *   set_misr_specs.pro
   ;
   ;  *   set_roots_vers.pro
   ;
   ;  *   strcat.pro
   ;
   ;  *   strstr.pro
   ;
   ;  *   str2block.pro
   ;
   ;  *   str2orbit.pro
   ;
   ;  *   str2path.pro
   ;
   ;  *   today.pro
   ;
   ;  REMARKS:
   ;
   ;  *   NOTE 1: The optional input keyword parameters MAP_BRF and
   ;      MAP_QUAL permit the selective generation of maps. If neither of
   ;      these keywords is set, no maps are generated, but if both
   ;      keywords are set, 197 files are generated. A text file with the
   ;      map legend is generated for each map that is produced.
   ;
   ;  EXAMPLES:
   ;
   ;      IDL> misr_mode = 'GM'
   ;      IDL> misr_path = 168
   ;      IDL> misr_orbit = 65487L
   ;      IDL> misr_block = 110
   ;      IDL> verbose = 1
   ;      IDL> debug = 1
   ;      IDL> rc = heap_l1b2_block(misr_mode, misr_path, $
   ;         misr_orbit, misr_block, misr_ptr, radrd_ptr, $
   ;         rad_ptr, brf_ptr, rdqi_ptr, scalf_ptr, convf_ptr, $
   ;         VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond)
   ;      IDL> prefix = 'test'
   ;      IDL> n_masks = 0
   ;      IDL> scl_rgb_min = 0.0
   ;      IDL> scl_rgb_max = 0.0
   ;      IDL> scl_nir_min = 0.0
   ;      IDL> scl_nir_max = 0.0
   ;      IDL> rgb_low = 1
   ;      IDL> rgb_high = 1
   ;      IDL> per_band = 1
   ;      IDL> log_it = 1
   ;      IDL> log_folder = ''
   ;      IDL> map_brf = 1
   ;      IDL> map_qual = 1
   ;      IDL> map_folder = ''
   ;      IDL> rc = map_l1b2(misr_ptr, radrd_ptr, brf_ptr, $
   ;         rdqi_ptr, prefix, N_MASKS = n_masks, $
   ;         SCL_RGB_MIN = scl_rgb_min, SCL_RGB_MAX = scl_rgb_max, $
   ;         SCL_NIR_MIN = scl_nir_min, SCL_NIR_MAX = scl_nir_max, $
   ;         RGB_LOW = rgb_low, RGB_HIGH = rgb_high, $
   ;         PER_BAND = per_band, LOG_IT = log_it, $
   ;         LOG_FOLDER = log_folder, MAP_BRF = map_brf, $
   ;         MAP_QUAL = map_qual, MAP_FOLDER = map_folder, $
   ;         VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond)
   ;      Saved ~/MISR_HR/Outcomes/
   ;         P168-O065487-B110/GM/L1B2/Maps_L1B2/
   ;         Log_L1B2_test-map-nm0_GM-P168-O065487-
   ;         B110_2012-04-10_2019-10-27.txt
   ;      IDL> PRINT, 'rc = ' + strstr(rc)
   ;      rc = 0
   ;
   ;  REFERENCES:
   ;
   ;  *   Michel M. Verstraete, Linda A. Hunt and Veljko M.
   ;      Jovanovic (2019) Improving the usability of the MISR L1B2
   ;      Georectified Radiance Product (2000–present) in land surface
   ;      applications, _Earth System Science Data Discussions (ESSDD)_,
   ;      Vol. 2019, p. 1–31, available from
   ;      https://www.earth-syst-sci-data-discuss.net/essd-2019-210/ (DOI:
   ;      10.5194/essd-2019-210).
   ;
   ;  *   Michel M. Verstraete, Linda A. Hunt and Veljko M.
   ;      Jovanovic (2020) Multi-angle Imaging SpectroRadiometer (MISR)
   ;      L1B2 Georectified Radiance Product (2000–present) in land surface
   ;      applications, _Earth System Science Data (ESSD)_, Vol. 12,
   ;      p. 1321-1346, available from
   ;      https://www.earth-syst-sci-data-discuss.net/essd-2019-210/
   ;      (DOI: 10.5194/essd-12-1321-2020).
   ;
   ;  VERSIONING:
   ;
   ;  *   2019–02–28: Version 1.0 — Initial release.
   ;
   ;  *   2019–03–07: Version 2.00 — Include the MAP_BRF and MAP_POORBAD
   ;      keyword parameters, merge the codes originally found in
   ;      functions map_l1b2_block.pro and map_l1b2_miss.pro, and initial
   ;      public release.
   ;
   ;  *   2019–03–20: Version 2.10 — Update the handling of the optional
   ;      input keyword parameter VERBOSE and generate the software
   ;      version consistent with the published documentation.
   ;
   ;  *   2019–04–05: Version 2.11 — Update the code to accept the
   ;      variable n_masks as a keyword rather than a positional
   ;      parameter, and expand the allowed range of values to [0, 3].
   ;
   ;  *   2019–04–18: Version 2.12 — Add code to set the BUFFER keyword
   ;      parameter as a function of the VERBOSE keyword parameter,
   ;      re-dimension the colorbars and insert them in the right edge
   ;      area of the corresponding B&W maps, and generate a legend for
   ;      each map.
   ;
   ;  *   2019–05–02: Version 2.13 — Bug fix: Encapsulate folder and file
   ;      creation in IF statements, deprecate the keyword parameter
   ;      MAP_POORBAD as the quality maps now show all values of RDQI.
   ;
   ;  *   2019–08–20: Version 2.1.0 — Adopt revised coding and
   ;      documentation standards (in particular regarding the use of
   ;      verbose and the assignment of numeric return codes), and switch
   ;      to 3-parts version identifiers.
   ;
   ;  *   2019–09–16: Version 2.1.1 — Improve the log file, update the
   ;      documentation, add the keywords TEST_ID, FIRST_LINE and
   ;      LAST_LINE to include additional information in the map legends
   ;      whenever missing data have been artificially inserted in the
   ;      L1B2 data buffers.
   ;
   ;  *   2019–09–28: Version 2.1.2 — Update the code to modify the
   ;      default log and map output directories, and use the current
   ;      version of the function hr2lr.pro.
   ;
   ;  *   2020–03–28: Version 2.1.3 — Update the code to output diagnostic
   ;      information on the number of good, fair, poor, bad, obscured,
   ;      edge and bad pixels in the log file, and update the
   ;      documentation.
   ;
   ;  *   2020–03–30: Version 2.1.5 — Software version described in the
   ;      preprint published in _ESSDD_ referenced above.
   ;
   ;  *   2020–05–03: Version 2.1.6 — Update the code to close the image
   ;      objects after they have been saved.
   ;
   ;  *   2020–05–10: Version 2.1.7 — Software version described in the
   ;      peer-reviewed paper published in _ESSD_ referenced above.
   ;Sec-Lic
   ;  INTELLECTUAL PROPERTY RIGHTS
   ;
   ;  *   Copyright (C) 2017-2020 Michel M. Verstraete.
   ;
   ;      Permission is hereby granted, free of charge, to any person
   ;      obtaining a copy of this software and associated documentation
   ;      files (the “Software”), to deal in the Software without
   ;      restriction, including without limitation the rights to use,
   ;      copy, modify, merge, publish, distribute, sublicense, and/or
   ;      sell copies of the Software, and to permit persons to whom the
   ;      Software is furnished to do so, subject to the following three
   ;      conditions:
   ;
   ;      1. The above copyright notice and this permission notice shall
   ;      be included in their entirety in all copies or substantial
   ;      portions of the Software.
   ;
   ;      2. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY
   ;      KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   ;      WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
   ;      AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   ;      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   ;      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   ;      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   ;      OTHER DEALINGS IN THE SOFTWARE.
   ;
   ;      See: https://opensource.org/licenses/MIT.
   ;
   ;      3. The current version of this Software is freely available from
   ;
   ;      https://github.com/mmverstraete.
   ;
   ;  *   Feedback
   ;
   ;      Please send comments and suggestions to the author at
   ;      MMVerstraete@gmail.com
   ;Sec-Cod

   COMPILE_OPT idl2, HIDDEN

   ;  Get the name of this routine:
   info = SCOPE_TRACEBACK(/STRUCTURE)
   rout_name = info[N_ELEMENTS(info) - 1].ROUTINE

   ;  Initialize the default return code:
   return_code = 0

   ;  Set the default values of flags and essential output keyword parameters:
   IF (~KEYWORD_SET(n_masks)) THEN n_masks = 0
   IF (~KEYWORD_SET(test_id)) THEN BEGIN
      test_id = ''
      IF (test_id EQ '') THEN BEGIN
         first_line = MAKE_ARRAY(9, 4, /INTEGER, VALUE = -1)
         last_line = MAKE_ARRAY(9, 4, /INTEGER, VALUE = -1)
      ENDIF
   ENDIF
   IF (KEYWORD_SET(log_it)) THEN log_it = 1 ELSE log_it = 0
   IF (KEYWORD_SET(map_brf)) THEN map_brf = 1 ELSE map_brf = 0
   IF (KEYWORD_SET(map_qual)) THEN map_qual = 1 ELSE map_qual = 0
   IF (KEYWORD_SET(verbose)) THEN BEGIN
      IF (is_numeric(verbose)) THEN verbose = FIX(verbose) ELSE verbose = 0
      IF (verbose LT 0) THEN verbose = 0
      IF (verbose GT 3) THEN verbose = 3
   ENDIF ELSE verbose = 0
   IF (KEYWORD_SET(debug)) THEN debug = 1 ELSE debug = 0
   excpt_cond = ''

   IF (verbose GT 1) THEN PRINT, 'Entering ' + rout_name + '.'

   ;  Control the amount of output on the console during processing:
   IF (verbose LT 3) THEN buffer = 1 ELSE buffer = 0

   IF (debug) THEN BEGIN

   ;  Return to the calling routine with an error message if one or more
   ;  positional parameters are missing:
      n_reqs = 5
      IF (N_PARAMS() NE n_reqs) THEN BEGIN
         error_code = 100
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': Routine must be called with ' + strstr(n_reqs) + $
            ' positional parameters: misr_ptr, radrd_ptr, brf_ptr, ' + $
            'rdqi_ptr, prefix.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if either of the
   ;  input positional parameters misr_ptr, radrd_ptr, brf_ptr, or rdqi_ptr
   ;  is not of type POINTER:
      res0 = is_pointer(misr_ptr)
      res1 = is_pointer(radrd_ptr)
      res2 = is_pointer(brf_ptr)
      res3 = is_pointer(rdqi_ptr)
      IF ((res0 NE 1) OR (res1 NE 1) OR (res2 NE 1) OR (res3 NE 1)) THEN BEGIN
         error_code = 110
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': One or more of the input positional parameters misr_ptr, ' + $
            'radrd_ptr, brf_ptr, or rdqi_ptr is not of type POINTER.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if either of the
   ;  input positional parameters radrd_ptr, brf_ptr, or rdqi_ptr is not an
   ;  array:
      res1 = is_array(radrd_ptr)
      res2 = is_array(brf_ptr)
      res3 = is_array(rdqi_ptr)
      IF ((res1 NE 1) OR (res2 NE 1) OR (res3 NE 1)) THEN BEGIN
         error_code = 120
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': One or more of the input positional parameters radrd_ptr, ' + $
            'brf_ptr, or rdqi_ptr is not an array.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if either of the
   ;  input positional parameters radrd_ptr, brf_ptr, or rdqi_ptr does not
   ;  contain 36 elements:
      res1 = N_ELEMENTS(radrd_ptr)
      res2 = N_ELEMENTS(brf_ptr)
      res3 = N_ELEMENTS(rdqi_ptr)
      IF ((res1 NE 36) OR (res2 NE 36) OR (res3 NE 36)) $
         THEN BEGIN
         error_code = 130
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': One or more of the input positional parameters radrd_ptr, ' + $
            'brf_ptr, or rdqi_ptr does not contain 36 elements.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'prefix' is not of type STRING:
      IF (is_string(prefix) NE 1) THEN BEGIN
         error_code = 140
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter prefix is not of type STRING.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  keyword parameter 'n_masks' is set to an invalid value:
      IF (KEYWORD_SET(n_masks)) THEN BEGIN
         IF ((n_masks LT 0) OR (n_masks GT 3)) THEN BEGIN
            error_code = 150
            excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
               ': The input keyword parameter n_masks must be in [0, 3].'
            RETURN, error_code
         ENDIF
      ENDIF
   ENDIF

   ;  Set the MISR specifications:
   misr_specs = set_misr_specs()
   n_cams = misr_specs.NCameras
   misr_cams = misr_specs.CameraNames
   n_bnds = misr_specs.NBands
   misr_bnds = misr_specs.BandNames

   ;  Identify the current operating system and computer name:
   rc = get_host_info(os_name, comp_name, $
      DEBUG = debug, EXCPT_COND = excpt_cond)
   IF (debug AND (rc NE 0)) THEN BEGIN
      error_code = 98
      excpt_cond = 'Warning ' + strstr(error_code) + ' in ' + rout_name + $
         ': ' + excpt_cond
      PRINT, excpt_cond
   ENDIF

   ;  Set the default folders and version identifiers of the MISR and
   ;  MISR-HR files on this computer, and return to the calling routine if
   ;  there is an internal error, but not if the computer is unrecognized, as
   ;  root addresses can be overridden by input keyword parameters:
   rc_roots = set_roots_vers(root_dirs, versions, $
      DEBUG = debug, EXCPT_COND = excpt_cond)
   IF (debug AND (rc_roots GE 100)) THEN BEGIN
      error_code = 199
      excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
         ': ' + excpt_cond
      RETURN, error_code
   ENDIF

   ;  Get today's date:
   date = today(FMT = 'ymd')

   ;  Get today's date and time:
   date_time = today(FMT = 'nice')

   ;  Retrieve the MISR Mode, Path, Orbit, Block and Version identifiers:
   temp = *misr_ptr
   misr_mode = temp[0]
   misr_path_str = temp[1]
   misr_orbit_str = temp[2]
   misr_block_str = temp[3]
   misr_version = temp[4]

   pob_str = strcat([misr_path_str, misr_orbit_str, misr_block_str], '-')
   mpob_str = strcat([misr_mode, pob_str], '-')

   rc = str2path(misr_path_str, misr_path)
   rc = str2orbit(misr_orbit_str, misr_orbit)
   rc = str2block(misr_block_str, misr_block)

   ;  Get the date of acquisition of this MISR Orbit:
   acquis_date = orbit2date(LONG(misr_orbit), DEBUG = debug, $
      EXCPT_COND = excpt_cond)
   IF (debug AND (excpt_cond NE '')) THEN BEGIN
      error_code = 200
      excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
         ': ' + excpt_cond
      RETURN, error_code
   ENDIF

   ;  Return to the calling routine with an error message if the routine
   ;  'set_roots_vers.pro' could not assign valid values to the array root_dirs
   ;  and the required MISR and MISR-HR root folders have not been initialized:
   IF (debug AND (rc_roots EQ 99)) THEN BEGIN
      IF ((log_it AND (~KEYWORD_SET(log_folder))) OR $
         (~KEYWORD_SET(map_folder))) THEN BEGIN
         error_code = 299
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': ' + excpt_cond + ' And at least one of the optional input ' + $
            'keyword parameters log_folder, map_folder is not specified.'
         RETURN, error_code
      ENDIF
   ENDIF

   ;  Set the directory address of the folder containing the output map files:
   IF (KEYWORD_SET(map_folder)) THEN BEGIN
      map_fpath = map_folder
   ENDIF ELSE BEGIN
      map_fpath = root_dirs[3] + pob_str + PATH_SEP() + $
         misr_mode + PATH_SEP() + 'L1B2' + PATH_SEP() + 'Maps_L1B2'

   ;  Update the log path if this is a test run:
         IF (test_id NE '') THEN map_fpath = map_fpath + '_' + test_id
   ENDELSE
   rc = force_path_sep(map_fpath)

   ;  Check that the output directory 'map_fpath' exists and is writable, and
   ;  if not, create it:
   res = is_writable_dir(map_fpath, /CREATE)
   IF (debug AND (res NE 1)) THEN BEGIN
      error_code = 400
      excpt_cond = 'Error ' + strstr(error_code) + ' in ' + $
         rout_name + ': The directory map_fpath is unwritable.'
      RETURN, error_code
   ENDIF

   IF (log_it) THEN BEGIN

   ;  Set the directory address of the folder containing the output log file:
      IF (KEYWORD_SET(log_folder)) THEN BEGIN
         log_fpath = log_folder
      ENDIF ELSE BEGIN
         log_fpath = root_dirs[3] + pob_str + PATH_SEP() + $
            misr_mode + PATH_SEP() + 'L1B2' + PATH_SEP() + 'Maps_L1B2'

   ;  Update the log path if this is a test run:
         IF (test_id NE '') THEN log_fpath = log_fpath + '_' + test_id
      ENDELSE
      rc = force_path_sep(log_fpath)

   ;  Check that the output directory 'log_fpath' exists and is writable, and
   ;  if not, create it:
      res = is_writable_dir(log_fpath, /CREATE)
      IF (debug AND (res NE 1)) THEN BEGIN
         error_code = 410
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + $
            rout_name + ': The directory log_fpath is unwritable.'
         RETURN, error_code
      ENDIF

   ;  Generate the specification of the log file:
      log_fname = 'Log_L1B2_' + prefix + '-map-nm' + strstr(n_masks) + $
         '_' + mpob_str + '_' + acquis_date + '_' + date + '.txt'
      log_fspec = log_fpath + log_fname

      fmt1 = '(A30, A)'

   ;  Open the log file and start recording events:
      OPENW, log_unit, log_fspec, /GET_LUN
      PRINTF, log_unit, 'File name: ', FILE_BASENAME(log_fspec), $
         FORMAT = fmt1
      PRINTF, log_unit, 'Folder name: ', FILE_DIRNAME(log_fspec, $
         /MARK_DIRECTORY), FORMAT = fmt1
      PRINTF, log_unit, 'Generated by: ', rout_name, FORMAT = fmt1
      PRINTF, log_unit, 'Generated on: ', comp_name, FORMAT = fmt1
      PRINTF, log_unit, 'Saved on: ', date_time, FORMAT = fmt1
      PRINTF, log_unit

      PRINTF, log_unit, 'Date of MISR acquisition: ', acquis_date, FORMAT = fmt1
      PRINTF, log_unit

      IF (misr_mode EQ 'GM') THEN BEGIN
         nf_map = 53
         nf_tot = 197
      ENDIF ELSE BEGIN
         nf_map = 45
         nf_tot = 181
      ENDELSE

      PRINTF, log_unit, 'Content: ', 'Log file created in conjunction ' + $
         'with the generation of'
      PRINTF, log_unit, 'some or all of the following ' + strstr(nf_tot) + $
         ' files:', FORMAT = fmt1
      PRINTF, log_unit

      PRINTF, log_unit, 'Color RDQI maps: ', $
         '36, one per data channel', FORMAT = fmt1
      PRINTF, log_unit, 'Legends for RDQI maps: ', $
         '36, one per RDQI map', FORMAT = fmt1

      PRINTF, log_unit, 'B&W L1B2 maps (w/ cbars): ', $
         '36, one per data channel', FORMAT = fmt1
      PRINTF, log_unit, 'Colorbars for B&W L1B2 maps: ', $
         '18, 9 for the VIS (Blue/Green/Red) and 9 for the NIR data channels', $
         FORMAT = fmt1
      PRINTF, log_unit, 'Legends for B&W L1B2 maps: ', $
         '36, one per data channel', FORMAT = fmt1

      IF (misr_mode EQ 'GM') THEN BEGIN
         PRINTF, log_unit, 'RGB L1B2 maps: ', $
            '17, two per off-nadir camera and one for AN', FORMAT = fmt1
         PRINTF, log_unit, 'Legends for RGB L1B2 maps: ', $
            '17, two per off-nadir camera and one for AN', FORMAT = fmt1
      ENDIF ELSE BEGIN
         PRINTF, log_unit, 'RGB L1B2 maps: ', $
            '9, one per camera', FORMAT = fmt1
         PRINTF, log_unit, 'Legends for RGB L1B2 maps: ', $
            '9, one per camera', FORMAT = fmt1
      ENDELSE

      PRINTF, log_unit, 'Log file: ', '1', FORMAT = fmt1

      PRINTF, log_unit
      PRINTF, log_unit, 'MISR L1B2 metadata: ', '', FORMAT = fmt1
      PRINTF, log_unit, 'misr_mode: ', misr_mode, FORMAT = fmt1
      PRINTF, log_unit, 'misr_path: ', misr_path_str, FORMAT = fmt1
      PRINTF, log_unit, 'misr_orbit: ', misr_orbit_str, FORMAT = fmt1
      PRINTF, log_unit, 'misr_block: ', misr_block_str, FORMAT = fmt1
      PRINTF, log_unit, 'misr_version: ', misr_version, FORMAT = fmt1
      PRINTF, log_unit, 'Output map directory: ', map_fpath, FORMAT = fmt1
      PRINTF, log_unit
   ENDIF

   ;  Set the default set of maps for Global Mode input data:
   IF (misr_mode EQ 'GM') THEN BEGIN
      IF ((~KEYWORD_SET(rgb_low)) AND $
         (~KEYWORD_SET(rgb_high)) AND $
         (~KEYWORD_SET(per_band))) THEN rgb_low = 1

      IF (log_it) THEN BEGIN
         PRINTF, log_unit, 'Mapping options (GM files): ', FORMAT = fmt1
         IF (KEYWORD_SET(rgb_low)) THEN PRINTF, log_unit, $
            '', 'Option rgb_low has been requested.', FORMAT = fmt1 $
            ELSE PRINTF, log_unit, $
            '', 'Option rgb_low has not been requested.', FORMAT = fmt1
         IF (KEYWORD_SET(rgb_high)) THEN PRINTF, log_unit, $
            '', 'Option rgb_high has been requested.', FORMAT = fmt1 $
            ELSE PRINTF, log_unit, $
            '', 'Option rgb_high has not been requested.', FORMAT = fmt1
         IF (KEYWORD_SET(per_band)) THEN PRINTF, log_unit, $
            '', 'Option per_band has been requested.', FORMAT = fmt1 $
            ELSE PRINTF, log_unit, $
            '', 'Option per_band has not been requested.', FORMAT = fmt1
         PRINTF, log_unit
         FLUSH, log_unit
      ENDIF
   ENDIF ELSE BEGIN
      IF (log_it) THEN BEGIN
         PRINTF, log_unit, 'Mapping options (LM files): ', FORMAT = fmt1
         IF (KEYWORD_SET(per_band)) THEN PRINTF, log_unit, $
            '', 'Option per_band has been requested.', FORMAT = fmt1 $
            ELSE PRINTF, log_unit, $
            '', 'Option per_band has not been requested.', FORMAT = fmt1
         PRINTF, log_unit
         FLUSH, log_unit
      ENDIF
   ENDELSE

   ;  Set the generic map filename elements:
   map_fname1 = 'Map_L1B2_Brf_' + prefix + '-nm' + strstr(n_masks)
   map_fname2 = mpob_str
   map_fname3 = acquis_date + '_' + date + '.png'

   ;  === Map the L1B2 Brf data ===============================================

   IF (map_brf) THEN BEGIN

   ;  *** WARNING ***: The array rgb_bands is specifically dimensioned to
   ;  generate RGB maps. Treat the NIR band spectral data separately, because
   ;  it requires different stretchings.

   ;  Name the RGB spectral bands. Note that the order of the spectral bands
   ;  here is different from the standard order [Blue, Green, Red, NIR]:
      rgb_bands = ['Red', 'Green', 'Blue']

   ;  Iterate over the 9 cameras:
      FOR cam = 0, n_cams - 1 DO BEGIN

         IF (log_it) THEN BEGIN
            tit = 'Mapping Brf fields of Camera ' + misr_cams[cam]
            PRINTF, log_unit, tit
            PRINTF, log_unit, strrepeat('-', STRLEN(tit), $
               DEBUG = debug, EXCPT_COND = excpt_cond)
            PRINTF, log_unit
         ENDIF

   ;  Access the L1B2 brf data product in the 4 spectral bands for the
   ;  current camera:
         blue = *brf_ptr[cam, 0]
         green = *brf_ptr[cam, 1]
         red = *brf_ptr[cam, 2]
         nir = *brf_ptr[cam, 3]

   ;  Compute the minimum and maximum valid (non-zero) BRF values found in
   ;  each spectral band:
         idx = WHERE(blue GT 0.0, n_gud_blue)
         IF (n_gud_blue GT 0) THEN BEGIN
            min_blue = MIN(blue[idx])
            max_blue = MAX(blue[idx])
         ENDIF ELSE BEGIN
            min_blue = 0.0
            max_blue = 1.0
         ENDELSE

         idx = WHERE(green GT 0.0, n_gud_green)
         IF (n_gud_green GT 0) THEN BEGIN
            min_green = MIN(green[idx])
            max_green = MAX(green[idx])
         ENDIF ELSE BEGIN
            min_green = 0.0
            max_green = 1.0
         ENDELSE

         idx = WHERE(red GT 0.0, n_gud_red)
         IF (n_gud_red GT 0) THEN BEGIN
            min_red = MIN(red[idx])
            max_red = MAX(red[idx])
         ENDIF ELSE BEGIN
            min_red = 0.0
            max_red = 1.0
         ENDELSE

         idx = WHERE(nir GT 0.0, n_gud_nir)
         IF (n_gud_nir GT 0) THEN BEGIN
            min_nir = MIN(nir[idx])
            max_nir = MAX(nir[idx])
         ENDIF ELSE BEGIN
            min_nir = 0.0
            max_nir = 1.0
         ENDELSE

         IF (log_it) THEN BEGIN
            fmt2 = '(A21, A)'
            PRINTF, log_unit, 'Minima and maxima ToA Brf in each ' + $
               'spectral channel:'
            PRINTF, log_unit, 'min_red = ', strstr(min_red), FORMAT = fmt2
            PRINTF, log_unit, 'max_red = ', strstr(max_red), FORMAT = fmt2
            PRINTF, log_unit, 'min_green = ', strstr(min_green), FORMAT = fmt2
            PRINTF, log_unit, 'max_green = ', strstr(max_green), FORMAT = fmt2
            PRINTF, log_unit, 'min_blue = ', strstr(min_blue), FORMAT = fmt2
            PRINTF, log_unit, 'max_blue = ', strstr(max_blue), FORMAT = fmt2
            PRINTF, log_unit, 'min_nir = ', strstr(min_nir), FORMAT = fmt2
            PRINTF, log_unit, 'max_nir = ', strstr(max_nir), FORMAT = fmt2
            PRINTF, log_unit
         ENDIF

   ;  Manage the scaling factors for this camera:
         IF (KEYWORD_SET(scl_rgb_min)) THEN BEGIN
            IF (scl_rgb_min EQ -1) THEN BEGIN
               scl_rgb_min_eff = MIN([min_blue, min_green, min_red])
               scl_rgb_min_opt = ' (Actual RGB minimum)'
            ENDIF ELSE BEGIN
               scl_rgb_min_eff = scl_rgb_min
               scl_rgb_min_opt = ' (Specified RGB minimum)'
            ENDELSE
         ENDIF ELSE BEGIN
            scl_rgb_min_eff = 0.0
            scl_rgb_min_opt = ' (Default RGB minimum)'
         ENDELSE

         IF (KEYWORD_SET(scl_rgb_max)) THEN BEGIN
            IF (scl_rgb_max EQ -1) THEN BEGIN
               scl_rgb_max_eff = MAX([max_blue, max_green, max_red])
               scl_rgb_max_opt = ' (Actual RGB maximum)'
            ENDIF ELSE BEGIN
               scl_rgb_max_eff = scl_rgb_max
               scl_rgb_max_opt = ' (Specified RGB maximum)'
            ENDELSE
         ENDIF ELSE BEGIN
            scl_rgb_max_eff = 0.35
            scl_rgb_max_opt = ' (Default RGB maximum)'
         ENDELSE

         IF (KEYWORD_SET(scl_nir_min)) THEN BEGIN
            IF (scl_nir_min EQ -1) THEN BEGIN
               scl_nir_min_eff = min_nir
               scl_nir_min_opt = ' (Actual NIR minimum)'
            ENDIF ELSE BEGIN
               scl_nir_min_eff = scl_nir_min
               scl_nir_min_opt = ' (Specified NIR minimum)'
            ENDELSE
         ENDIF ELSE BEGIN
            scl_nir_min_eff = 0.0
            scl_nir_min_opt = ' (Default NIR minimum)'
         ENDELSE

         IF (KEYWORD_SET(scl_nir_max)) THEN BEGIN
            IF (scl_nir_max EQ -1) THEN BEGIN
               scl_nir_max_eff = max_nir
               scl_nir_max_opt = ' (Actual NIR maximum)'
            ENDIF ELSE BEGIN
               scl_nir_max_eff = scl_nir_max
               scl_nir_max_opt = ' (Specified NIR maximum)'
            ENDELSE
         ENDIF ELSE BEGIN
            scl_nir_max_eff = 0.50
            scl_nir_max_opt = ' (Default NIR maximum)'
         ENDELSE

         IF (log_it) THEN BEGIN
            PRINTF, log_unit, 'Stretching factors used for camera ' + $
               misr_cams[cam] + ':'
            PRINTF, log_unit, 'For the 3 visible spectral channels:'
            PRINTF, log_unit, '   scl_rgb_min_eff = ' + $
               strstr(scl_rgb_min_eff) + scl_rgb_min_opt + '.'
            PRINTF, log_unit, '   scl_rgb_max_eff = ' + $
               strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '.'
            PRINTF, log_unit, 'For the NIR spectral channel:'
            PRINTF, log_unit, '   scl_nir_min_eff = ' + $
               strstr(scl_nir_min_eff) + scl_nir_min_opt + '.'
            PRINTF, log_unit, '   scl_nir_max_eff = ' + $
               strstr(scl_nir_max_eff) + scl_nir_max_opt + '.'
            PRINTF, log_unit
         ENDIF

   ;  Get the dimensions of the red spectral band data set (which is always
   ;  available at the full spatial resolution):
         sz = SIZE(red, /DIMENSIONS)

   ;  If the input data is available from a Local Mode file, or from the AN
   ;  camera of a Global Mode file, all 3 spectral data fields are already at
   ;  the full spatial resolution, so the RGB map can be created immediately:
         IF ((misr_mode EQ 'LM') OR (misr_cams[cam] EQ 'AN')) THEN BEGIN
            img_dat = FLTARR(3, sz[0], sz[1])
            img_dat[0, *, *] = red
            img_dat[1, *, *] = green
            img_dat[2, *, *] = blue
            img = BYTSCL(img_dat, MIN = scl_rgb_min_eff, MAX = scl_rgb_max_eff)

   ;  Set the name of this RGB map file:
            map_fname = map_fname1 + $
               '_toabrf_' + $
               map_fname2 + $
               '-' + misr_cams[cam] + '-rgb-275_' + $
               map_fname3
            map_fspec = map_fpath + map_fname

   ;  Save the RGB map:
            WRITE_PNG, map_fspec, img, /ORDER
            IF (log_it) THEN BEGIN
               PRINTF, log_unit, '   - Saved the RGB map in'
               PRINTF, log_unit, '     ' + map_fname
            ENDIF

   ;  Save the legend for this high-resolution RGB map:
            legend_fname = map_fname.Replace('Map', 'Legend')
            legend_fname = legend_fname.Replace('png', 'txt')
            legend_fspec = map_fpath + legend_fname
            map_legend_txt = 'Red-Green-Blue (RGB) map of L1B2 Brf data ' + $
               'for MISR Mode ' + misr_mode + $
               ', Path ' + strstr(misr_path) + $
               ', Orbit ' + strstr(misr_orbit) + $
               ', Block ' + strstr(misr_block) + $
               ', and Camera ' + misr_cams[cam] + '. ' + $
               'Individual spectral channels are stretched between ' + $
               strstr(scl_rgb_min_eff) + scl_rgb_min_opt + ' and ' + $
               strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
               'The total size of the Block area is 563.2 km ' + $
               'across-track by 140.8 km along-track, while the ' + $
               'parallelogram-shaped ground area inside the Block ' + $
               'is about 380 km across-track.'
            IF ((test_id NE '') AND $
               ((first_line[cam, 0] NE -1) OR $
               (first_line[cam, 1] NE -1) OR $
               (first_line[cam, 2] NE -1))) THEN BEGIN
               map_legend_txt = map_legend_txt + ' Missing data have been ' + $
                  'artificially inserted in some of the L1B2 data buffers ' + $
                  'for testing purposes.'
            ENDIF
            OPENW, legend_unit, legend_fspec, /GET_LUN
            PRINTF, legend_unit, 'Legend for the similarly named map:'
            PRINTF, legend_unit, map_legend_txt
            CLOSE, legend_unit
            FREE_LUN, legend_unit

   ;  Generate the B&W maps for these 3 same individual red, green and blue
   ;  spectral bands if they have also been requested:
            IF KEYWORD_SET(per_band) THEN BEGIN

   ;  First, generate the colorbar legends to interpret the B&W visible and
   ;  NIR maps:
               w = WINDOW(DIMENSIONS = [120, 400], /NO_TOOLBAR, /BUFFER)
               cb = COLORBAR(RANGE = [scl_rgb_min_eff, scl_rgb_max_eff], $
                  TITLE = 'Gray scale for L1B2 VIS spectral maps from Cam ' + $
                     misr_cams[cam], $
                  FONT_STYLE = 2, $
                  POSITION = [0.5, 0.15, 0.9, 0.85], $
                  RGB_TABLE = 0, $
                  BORDER_ON = 1, $
                  TAPER = 3, $
                  ORIENTATION = 1)
               cb_fname1 = 'ColbarMaps_L1B2_' + prefix + '_toabrf-VIS_' + $
                  mpob_str + '-'
               cb_fname2 = misr_cams[cam] + '_' + acquis_date + '_' + date + $
                  '.png'
               l1b2_vis_cb_fspec = map_fpath + cb_fname1 + cb_fname2
               cb.Save, l1b2_vis_cb_fspec
               visbar = READ_PNG(l1b2_vis_cb_fspec)
               w.Close

               w = WINDOW(DIMENSIONS = [120, 400], /NO_TOOLBAR, /BUFFER)
               cbnir = COLORBAR(RANGE = [scl_nir_min_eff, scl_nir_max_eff], $
                  TITLE = 'Gray scale for L1B2 NIR spectral map from Cam ' + $
                     misr_cams[cam], $
                  FONT_STYLE = 2, $
                  POSITION = [0.5, 0.15, 0.9, 0.85], $
                  RGB_TABLE = 0, $
                  BORDER_ON = 1, $
                  TAPER = 3, $
                  ORIENTATION = 1)
               cb_fname1 = 'ColbarMaps_L1B2_' + prefix + '_toabrf-NIR_' + $
                  mpob_str + '-'
               cb_fname2 = misr_cams[cam] + '_' + acquis_date + '_' + date + $
                  '.png'
               l1b2_nir_cb_fspec = map_fpath + cb_fname1 + cb_fname2
               cbnir.Save, l1b2_nir_cb_fspec
               nirbar = READ_PNG(l1b2_nir_cb_fspec)
               w.Close

   ;  Loop over the 3 individual RGB bands and generate the B&W maps:
               FOR b = 0, N_ELEMENTS(rgb_bands) - 1 DO BEGIN
                  img = BYTSCL(img_dat[b, *, *], scl_rgb_min_eff, $
                     scl_rgb_max_eff)
                  img = REFORM(img)

   ;  Set the name of this individual band map file:
                  map_fname = map_fname1 + $
                     '_toabrf_' + $
                     map_fname2 + $
                     '-' + misr_cams[cam] + '-' + rgb_bands[b] + '-275_bar_' + $
                     map_fname3
                  map_fspec = map_fpath + map_fname

   ;  Set and save each of the B&W maps for each of the 3 RGB bands of this
   ;  camera:
                  sz = SIZE(img, /DIMENSIONS)
                  ibnd = IMAGE(img, DIMENSIONS = [sz[0], sz[1]], $
                     POSITION = [0, 0, 1, 1], /ORDER, BUFFER = buffer)
                  ir2 = IMAGE(visbar, /CURRENT, $
                     POSITION = [0.925, 0.1, 0.975, 0.9])
                  ibnd.Save, map_fspec
                  ibnd.Close

                  IF (log_it) THEN BEGIN
                     PRINTF, log_unit, '   - Saved the B&W map for band ' + $
                        rgb_bands[b] + ' in'
                     PRINTF, log_unit, '     ' + map_fname
                  ENDIF

   ;  Save the legend for each of these high-resolution maps in the visible
   ;  part of the solar spectrum:
                  legend_fname = map_fname.Replace('Map', 'Legend')
                  legend_fname = legend_fname.Replace('png', 'txt')
                  legend_fspec = map_fpath + legend_fname
                  map_legend_txt = 'Black and white map of L1B2 Brf data ' + $
                     'for MISR Mode ' + misr_mode + $
                     ', Path ' + strstr(misr_path) + $
                     ', Orbit ' + strstr(misr_orbit) + $
                     ', Block ' + strstr(misr_block) + $
                     ', Camera ' + misr_cams[cam] + $
                     ', and Band ' + rgb_bands[b] + '. ' + $
                     'This spectral channel is stretched between ' + $
                     strstr(scl_rgb_min_eff) + scl_rgb_min_opt + ' and ' + $
                     strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
                     'The total size of the Block area is 563.2 km ' + $
                     'across-track by 140.8 km along-track, while the ' + $
                     'parallelogram-shaped ground area inside the Block ' + $
                     'is about 380 km across-track.'
                  IF ((test_id NE '') AND $
                     ((first_line[cam, b] NE -1))) THEN BEGIN
                     map_legend_txt = map_legend_txt + ' Missing data ' + $
                        'have been artificially inserted in this ' + $
                        'L1B2 data buffer for testing purposes.'
                  ENDIF

                  OPENW, legend_unit, legend_fspec, /GET_LUN
                  PRINTF, legend_unit, 'Legend for the similarly named map:'
                  PRINTF, legend_unit, map_legend_txt
                  CLOSE, legend_unit
                  FREE_LUN, legend_unit
               ENDFOR

   ;  Generate the NIR map separately, using the NIR-specific scaling:
               img = BYTSCL(nir, scl_nir_min_eff, scl_nir_max_eff)
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-NIR-275_bar_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Set and save the B&W map for the NIR band of this camera:
               sz = SIZE(img, /DIMENSIONS)
               inir = IMAGE(img, DIMENSIONS = [sz[0], sz[1]], $
                  POSITION = [0, 0, 1, 1], /ORDER, BUFFER = buffer)
               ir2 = IMAGE(nirbar, /CURRENT, $
                  POSITION = [0.925, 0.1, 0.975, 0.9])
               inir.Save, map_fspec
               inir.Close

               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the B&W map for band ' + $
                     'NIR in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this high-resolution map in the near-infrared
   ;  part of the solar spectrum:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Black and white map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', Camera ' + misr_cams[cam] + $
                  ', and Band NIR. ' + $
                  'This spectral channel is stretched between ' + $
                  strstr(scl_nir_min_eff) + scl_nir_min_opt + ' and ' + $
                  strstr(scl_nir_max_eff) + scl_nir_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 3] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit
            ENDIF
         ENDIF ELSE BEGIN

   ;  Handle Global Mode off-nadir cameras, where the spatial resolution of
   ;  the non-red spectral channels is 1100 m instead of 275 m, and the red
   ;  channel is downsized to 1100 m before all pixels are duplicated to 275 m
   ;  format display purposes:
            IF KEYWORD_SET(RGB_LOW) THEN BEGIN
               image_low = FLTARR(3, sz[0], sz[1])
               lowres_red = hr2lr(red, 'Brf', $
                  DEBUG = debug, EXCPT_COND = excpt_cond)
               IF (debug AND (excpt_cond NE '')) THEN BEGIN
                  error_code = 500
                  excpt_cond = 'Error ' + strstr(error_code) + ' in ' + $
                     rout_name + ': ' + excpt_cond
                  RETURN, error_code
               ENDIF
               image_low[0, *, *] = lr2hr(lowres_red, $
                  DEBUG = debug, EXCPT_COND = excpt_cond)
               IF (debug AND (excpt_cond NE '')) THEN BEGIN
                  error_code = 510
                  excpt_cond = 'Error ' + strstr(error_code) + ' in ' + $
                     rout_name + ': ' + excpt_cond
                  RETURN, error_code
               ENDIF

               image_low[1, *, *] = lr2hr(green, $
                  DEBUG = debug, EXCPT_COND = excpt_cond)
               IF (debug AND (excpt_cond NE '')) THEN BEGIN
                  error_code = 520
                  excpt_cond = 'Error ' + strstr(error_code) + ' in ' + $
                     rout_name + ': ' + excpt_cond
                  RETURN, error_code
               ENDIF

               image_low[2, *, *] = lr2hr(blue, $
                  DEBUG = debug, EXCPT_COND = excpt_cond)
               IF (debug AND (excpt_cond NE '')) THEN BEGIN
                  error_code = 530
                  excpt_cond = 'Error ' + strstr(error_code) + ' in ' + $
                     rout_name + ': ' + excpt_cond
                  RETURN, error_code
               ENDIF

               img_low = BYTSCL(image_low, MIN = scl_rgb_min_eff, $
                  MAX = scl_rgb_max_eff)

   ;  Set the name of the RGB-Low off-nadir map file:
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-rgb-mixed-low_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Save the RGB-Low off-nadir map:
               WRITE_PNG, map_fspec, img_low, /ORDER
               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the low-resolution ' + $
                     '(Low) RGB map for camera ' + misr_cams[cam] + ' in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this mixed-resolution RGB map:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Red-Green-Blue (RGB) map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', and Camera ' + misr_cams[cam] + '. ' + $
                  'The high spatial resolution red spectral channel is ' + $
                  'first scaled down to match the lower spatial ' + $
                  'resolution of the blue and green spectral channel, ' + $
                  'and the resulting RGB map is then upscaled to the ' + $
                  'full spatial resolution to ease comparison with other ' + $
                  'maps. Individual spectral channels are stretched ' + $
                  'between ' + strstr(scl_rgb_min_eff) + scl_rgb_min_opt + $
                  ' and ' + strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 0] NE -1) OR $
                  (first_line[cam, 1] NE -1) OR $
                  (first_line[cam, 2] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit
            ENDIF

   ;  Handle Global Mode off-nadir cameras, where the spatial resolution of
   ;  the non-red spectral channels is 1100 m instead of 275 m, and the non-red
   ;  channels are upized to 275 m by duplication before creating the map:
            IF KEYWORD_SET(RGB_HIGH) THEN BEGIN
               image_high = FLTARR(3, sz[0], sz[1])
               image_high[0, *, *] = red
               image_high[1, *, *] = lr2hr(green, $
                  DEBUG = debug, EXCPT_COND = excpt_cond)
               image_high[2, *, *] = lr2hr(blue, $
                  DEBUG = debug, EXCPT_COND = excpt_cond)
               img_high = BYTSCL(image_high, MIN = scl_rgb_min_eff, $
                  MAX = scl_rgb_max_eff)

   ;  Set the name of the RGB-High off-nadir map file:
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-rgb-mixed-high_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Save the RGB-High off-nadir map:
               WRITE_PNG, map_fspec, img_high, /ORDER
               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the mixed-resolution ' + $
                     '(High) RGB map for camera ' + misr_cams[cam] + ' in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this mixed-resolution RGB map:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Red-Green-Blue (RGB) map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', and Camera ' + misr_cams[cam] + '. ' + $
                  'The low spatial resolution blue and green spectral ' + $
                  'channels are first scaled up to match the higher ' + $
                  'spatial resolution of the red spectral channel, ' + $
                  'and the resulting RGB map is then generated at that ' + $
                  'full spatial resolution to ease comparison with other ' + $
                  'maps. Individual spectral channels are stretched ' + $
                  'between ' + strstr(scl_rgb_min_eff) + scl_rgb_min_opt + $
                  ' and ' + strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 0] NE -1) OR $
                  (first_line[cam, 1] NE -1) OR $
                  (first_line[cam, 2] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit
            ENDIF

   ;  Generate the maps for the individual bands if they have also been
   ;  requested, distinguishing between the red band at the full spatial
   ;  resolution and the other 3 bands at the reduced spatial resolution.
            IF KEYWORD_SET(per_band) THEN BEGIN

   ;  First, generate the colorbar legends to interpret the B&W visible and
   ;  NIR maps:
               w = WINDOW(DIMENSIONS = [120, 400], /NO_TOOLBAR, /BUFFER)
               cb = COLORBAR(RANGE = [scl_rgb_min_eff, scl_rgb_max_eff], $
                  TITLE = 'Gray scale for L1B2 VIS spectral maps from Cam ' + $
                     misr_cams[cam], $
                  FONT_STYLE = 2, $
                  POSITION = [0.5, 0.15, 0.9, 0.85], $
                  RGB_TABLE = 0, $
                  BORDER_ON = 1, $
                  TAPER = 3, $
                  ORIENTATION = 1)
               cb_fname1 = 'ColbarMaps_L1B2_' + prefix + '_toabrf-VIS_' + $
                  mpob_str + '-'
               cb_fname2 = misr_cams[cam] + '_' + acquis_date + '_' + date + $
                  '.png'
               l1b2_vis_cb_fspec = map_fpath + cb_fname1 + cb_fname2
               cb.Save, l1b2_vis_cb_fspec
               visbar = READ_PNG(l1b2_vis_cb_fspec)
               w.Close

               w = WINDOW(DIMENSIONS = [120, 400], /NO_TOOLBAR, /BUFFER)
               cbnir = COLORBAR(RANGE = [scl_nir_min_eff, scl_nir_max_eff], $
                  TITLE = 'Gray scale for L1B2 NIR spectral map from Cam ' + $
                     misr_cams[cam], $
                  FONT_STYLE = 2, $
                  POSITION = [0.5, 0.15, 0.9, 0.85], $
                  RGB_TABLE = 0, $
                  BORDER_ON = 1, $
                  TAPER = 3, $
                  ORIENTATION = 1)
               cb_fname1 = 'ColbarMaps_L1B2_' + prefix + '_toabrf-NIR_' + $
                  mpob_str + '-'
               cb_fname2 = misr_cams[cam] + '_' + acquis_date + '_' + date + $
                  '.png'
               l1b2_nir_cb_fspec = map_fpath + cb_fname1 + cb_fname2
               cbnir.Save, l1b2_nir_cb_fspec
               nirbar = READ_PNG(l1b2_nir_cb_fspec)
               w.Close

   ;  Next, do the Red band (always at high resolution):
               img = BYTSCL(red, MIN = scl_rgb_min_eff, MAX = scl_rgb_max_eff)

   ;  Set the name of the Red band map file:
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-Red-275_bar_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Set and save the B&W map for the red channel:
               ired = IMAGE(img, DIMENSIONS = [sz[0], sz[1]], $
                  POSITION = [0, 0, 1, 1], /ORDER, BUFFER = buffer)

               ir2 = IMAGE(visbar, /CURRENT, $
                  POSITION = [0.925, 0.1, 0.975, 0.9])
               ired.Save, map_fspec
               ired.Close

               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the high-resolution B&W ' + $
                     'map for camera ' + misr_cams[cam] + ' and band Red in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this high-resolution map in the red spectral band:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Black and white map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', Camera ' + misr_cams[cam] + $
                  ', and Band Red. ' + $
                  'This spectral channel is stretched between ' + $
                  strstr(scl_rgb_min_eff) + scl_rgb_min_opt + ' and ' + $
                  strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 2] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit

   ;  Do the Green band (always at low resolution):
               img = BYTSCL(lr2hr(green), MIN = scl_rgb_min_eff, $
                  MAX = scl_rgb_max_eff)

   ;  Set the name of the Green band map file:
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-Green-1100_bar_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Set and save the B&W map for the green channel:
               sz = SIZE(img, /DIMENSIONS)
               igreen = IMAGE(img, DIMENSIONS = [sz[0], sz[1]], $
                  POSITION = [0, 0, 1, 1], /ORDER, BUFFER = buffer)
               ir2 = IMAGE(visbar, /CURRENT, $
                  POSITION = [0.925, 0.1, 0.975, 0.9])
               igreen.Save, map_fspec
               igreen.Close

               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the high-resolution B&W ' + $
                     'map for camera ' + misr_cams[cam] + ' and band Green in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this low-resolution map in the green spectral band:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Black and white map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', Camera ' + misr_cams[cam] + $
                  ', and Band Green. ' + $
                  'This spectral channel is stretched between ' + $
                  strstr(scl_rgb_min_eff) + scl_rgb_min_opt + ' and ' + $
                  strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 1] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit

   ;  Do the Blue band (always at low resolution):
               img = BYTSCL(lr2hr(blue), MIN = scl_rgb_min_eff, $
                  MAX = scl_rgb_max_eff)

   ;  Set the name of the Blue band map file:
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-Blue-1100_bar_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Set and save the B&W map for the blue channel:
               sz = SIZE(img, /DIMENSIONS)
               iblue = IMAGE(img, DIMENSIONS = [sz[0], sz[1]], $
                  POSITION = [0, 0, 1, 1], /ORDER, BUFFER = buffer)
               ir2 = IMAGE(visbar, /CURRENT, $
                  POSITION = [0.925, 0.1, 0.975, 0.9])
               iblue.Save, map_fspec
               iblue.Close

               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the high-resolution B&W ' + $
                  'map for camera ' + misr_cams[cam] + ' and band Blue in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this low-resolution map in the blue spectral band:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Black and white map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', Camera ' + misr_cams[cam] + $
                  ', and Band Blue. ' + $
                  'This spectral channel is stretched between ' + $
                  strstr(scl_rgb_min_eff) + scl_rgb_min_opt + ' and ' + $
                  strstr(scl_rgb_max_eff) + scl_rgb_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 0] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit

   ;  Do the NIR band (always at low resolution):
               img = BYTSCL(lr2hr(nir), MIN = scl_nir_min_eff, $
                  MAX = scl_nir_max_eff)

   ;  Set the name of the NIR band map file:
               map_fname = map_fname1 + $
                  '_toabrf_' + $
                  map_fname2 + $
                  '-' + misr_cams[cam] + '-NIR-1100_bar_' + $
                  map_fname3
               map_fspec = map_fpath + map_fname

   ;  Set and save the B&W map for the NIR channel:
               sz = SIZE(img, /DIMENSIONS)
               inir = IMAGE(img, DIMENSIONS = [sz[0], sz[1]], $
                  POSITION = [0, 0, 1, 1], /ORDER, BUFFER = buffer)
               ir2 = IMAGE(nirbar, /CURRENT, $
                  POSITION = [0.925, 0.1, 0.975, 0.9])
               inir.Save, map_fspec
               inir.Close

               IF (log_it) THEN BEGIN
                  PRINTF, log_unit, '   - Saved the high-resolution B&W ' + $
                  'map for camera ' + misr_cams[cam] + ' and band NIR in'
                  PRINTF, log_unit, '     ' + map_fname
               ENDIF

   ;  Save the legend for this low-resolution map in the NIR spectral band:
               legend_fname = map_fname.Replace('Map', 'Legend')
               legend_fname = legend_fname.Replace('png', 'txt')
               legend_fspec = map_fpath + legend_fname
               map_legend_txt = 'Black and white map of L1B2 Brf data ' + $
                  'for MISR Mode ' + misr_mode + $
                  ', Path ' + strstr(misr_path) + $
                  ', Orbit ' + strstr(misr_orbit) + $
                  ', Block ' + strstr(misr_block) + $
                  ', Camera ' + misr_cams[cam] + $
                  ', and Band NIR. ' + $
                  'This spectral channel is stretched between ' + $
                  strstr(scl_nir_min_eff) + scl_nir_min_opt + ' and ' + $
                  strstr(scl_nir_max_eff) + scl_nir_max_opt + '. ' + $
                  'The total size of the Block area is 563.2 km ' + $
                  'across-track by 140.8 km along-track, while the ' + $
                  'parallelogram-shaped ground area inside the Block ' + $
                  'is about 380 km across-track.'
               IF ((test_id NE '') AND $
                  ((first_line[cam, 3] NE -1))) THEN BEGIN
                  map_legend_txt = map_legend_txt + ' Missing data ' + $
                     'have been artificially inserted in this ' + $
                     'L1B2 data buffer for testing purposes.'
               ENDIF

               OPENW, legend_unit, legend_fspec, /GET_LUN
               PRINTF, legend_unit, 'Legend for the similarly named map:'
               PRINTF, legend_unit, map_legend_txt
               CLOSE, legend_unit
               FREE_LUN, legend_unit
            ENDIF
         ENDELSE
         IF (log_it) THEN PRINTF, log_unit

      ENDFOR   ;  End of loop on cameras
   ENDIF   ;  End of IF (map_brf)

   ;  === Map the L1B2 RDQI data ===============================================

   IF (map_qual) THEN BEGIN

   ;  Set the expected RDQI values and the colors in which they should be
   ;  mapped:
      good_vals = [0B, 1B, 2B, 3B, 4B, 5B]
      good_vals_cols = ['blue', 'green', 'orange', 'yellow', 'black', 'red']

   ;  Iterate over the 9 cameras:
      FOR cam = 0, n_cams - 1 DO BEGIN

         IF (log_it) THEN BEGIN
            PRINTF, log_unit
            tit1 = 'Mapping the RDQI fields of Camera ' + misr_cams[cam]
            tit2 = '(# of pixels in the output maps, not necessarily in ' + $
               'the input files)'
            PRINTF, log_unit, tit1
            PRINTF, log_unit, tit2
            PRINTF, log_unit, strrepeat('-', STRLEN(tit2), $
               DEBUG = debug, EXCPT_COND = excpt_cond)
         ENDIF

   ;  Iterate over the 4 spectral bands:
         FOR bnd = 0, n_bnds - 1 DO BEGIN
            rdqi_array = *rdqi_ptr[cam, bnd]
            radrd_array = *radrd_ptr[cam, bnd]
            IF ((misr_mode EQ 'GM') AND (cam NE 4) AND (bnd NE 2)) THEN BEGIN
               rdqi_array = lr2hr(rdqi_array)
               radrd_array = lr2hr(radrd_array)
            ENDIF
            byte_array = BYTARR(2048, 512)

   ;  Fill the byte_array array with data quality information:
            good = WHERE(rdqi_array EQ 0B, ngood)
            IF (ngood GT 0) THEN byte_array[good] = 0B
            fair = WHERE(rdqi_array EQ 1B, nfair)
            IF (nfair GT 0) THEN byte_array[fair] = 1B
            poor = WHERE(rdqi_array EQ 2B, npoor)
            IF (npoor GT 0) THEN byte_array[poor] = 2B
            obsc = WHERE(radrd_array EQ 65511, nobsc)
            IF (nobsc GT 0) THEN byte_array[obsc] = 3B
            edge = WHERE(radrd_array EQ 65515, nedge)
            IF (nedge GT 0) THEN byte_array[edge] = 4B
            bad = WHERE(radrd_array EQ 65523, nbad)
            IF (nbad GT 0) THEN byte_array[bad] = 5B

   ;  Report in the log file the number of pixels in each category:
         IF (log_it) THEN BEGIN
            PRINTF, log_unit, 'Spectral band = ', misr_bnds[bnd], FORMAT = fmt2
            PRINTF, log_unit, '   # good = ', strstr(ngood), FORMAT = fmt2
            PRINTF, log_unit, '   # fair = ', strstr(nfair), FORMAT = fmt2
            PRINTF, log_unit, '   # poor = ', strstr(npoor), FORMAT = fmt2
            PRINTF, log_unit, '   # obsc = ', strstr(nobsc), FORMAT = fmt2
            PRINTF, log_unit, '   # edge = ', strstr(nedge), FORMAT = fmt2
            PRINTF, log_unit, '   # bad = ', strstr(nbad), FORMAT = fmt2
            tot_pix = ngood + nfair + npoor + nobsc + nedge + nbad
            PRINTF, log_unit, '   Total = ', strstr(tot_pix), FORMAT = fmt2
         ENDIF

   ;  Set the name of the quality map:
            rdqi_fname = map_fname1 + $
               '_qual_' + $
               map_fname2 + $
               '-' + misr_cams[cam] + '-' + misr_bnds[bnd] + '_' + $
               map_fname3
            rdqi_fspec = map_fpath + rdqi_fname

   ;  Map the RDQI field:
            rc = make_bytemap(byte_array, good_vals, good_vals_cols, $
               rdqi_fspec, DEBUG = debug, EXCPT_COND = excpt_cond)

   ;  Save the legend for this low-resolution map in the NIR spectral band:
            rdqi_fname = FILE_BASENAME(rdqi_fspec)
            legend_fname = rdqi_fname.Replace('Map', 'Legend')
            legend_fname = legend_fname.Replace('png', 'txt')
            legend_fspec = map_fpath + legend_fname
            map_legend_txt = 'Map of L1B2 RDQI data ' + $
               'for MISR Mode ' + misr_mode + $
               ', Path ' + strstr(misr_path) + $
               ', Orbit ' + strstr(misr_orbit) + $
               ', Block ' + strstr(misr_block) + $
               ', Camera ' + misr_cams[cam] + $
               ', and Band ' + misr_bnds[bnd] + '. ' + $
               'Color coding: ' + $
               good_vals_cols[0] + ': RDQI = 0; ' + $
               good_vals_cols[1] + ': RDQI = 1; ' + $
               good_vals_cols[2] + ': RDQI = 2; ' + $
               good_vals_cols[3] + ': Missing data (obscuration); ' + $
               good_vals_cols[4] + ': Missing data (edge); ' + $
               good_vals_cols[5] + ': Missing data. ' + $
               'The total size of the Block area is 563.2 km ' + $
               'across-track by 140.8 km along-track, while the ' + $
               'parallelogram-shaped ground area inside the Block ' + $
               'is about 380 km across-track.'
            IF ((test_id NE '') AND $
               ((first_line[cam, bnd] NE -1))) THEN BEGIN
               map_legend_txt = map_legend_txt + ' Missing data ' + $
                  'have been artificially inserted in this ' + $
                  'L1B2 data buffer for testing purposes.'
            ENDIF

            OPENW, legend_unit, legend_fspec, /GET_LUN
            PRINTF, legend_unit, 'Legend for the similarly named map:'
            PRINTF, legend_unit, map_legend_txt
            CLOSE, legend_unit
            FREE_LUN, legend_unit
         ENDFOR
      ENDFOR
   ENDIF

   IF (log_it) THEN BEGIN
      FREE_LUN, log_unit
      CLOSE, log_unit
      IF (verbose GT 0) THEN BEGIN
         PRINT, 'Saved ' + log_fspec
      ENDIF
   ENDIF

   IF (verbose GT 1) THEN PRINT, 'Exiting ' + rout_name + '.'

   RETURN, return_code

END
