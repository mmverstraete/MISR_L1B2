FUNCTION get_bad_l1b2, misr_mode, misr_path, misr_orbit, misr_block, $
   bad_struct, VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond

   ;Sec-Doc
   ;  PURPOSE: This function identifies, counts and locates the pixels
   ;  flagged as bad or unusable for any purpose in each of the 9 MISR
   ;  L1B2 files specified by the given MODE, PATH, ORBIT and BLOCK, and
   ;  for each of the 4 spectral bands.
   ;
   ;  ALGORITHM: This function reads the scaled radiance measurements from
   ;  each of the 36 MISR L1B2 data channels for a given misr_mode,
   ;  misr_path, misr_orbit and misr_block and searches for data values
   ;  16380. If any are found, the number and locations of those pixels in
   ;  the BLOCK are reported in the output structure bad_struct.
   ;
   ;  SYNTAX:
   ;  rc = get_bad_l1b2(misr_mode, misr_path, misr_orbit, misr_block, $
   ;  bad_struct, DEBUG = debug, EXCPT_COND = excpt_cond)
   ;
   ;  POSITIONAL PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   misr_mode {STRING} [I]: The selected MISR MODE.
   ;
   ;  *   misr_path {INTEGER} [I]: The selected MISR PATH number.
   ;
   ;  *   misr_orbit {LONG} [I]: The selected MISR ORBIT number.
   ;
   ;  *   misr_block {INTEGER} [I]: The selected MISR BLOCK number.
   ;
   ;  *   bad_struct {STRUCTURE} [O]: The structure containing the
   ;      information on the bad pixels contained in the MISR L1B2 files.
   ;
   ;  KEYWORD PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   VERBOSE = verbose {INT} [I] (Default value: 0): Flag to activate
   ;      (1) or skip (0) printing progress information on the console.
   ;
   ;  *   DEBUG = debug {INT} [I] (Default value: 0): Flag to activate (1)
   ;      or skip (0) debugging tests.
   ;
   ;  *   EXCPT_COND = excpt_cond {STRING} [O] (Default value: ”):
   ;      Description of the exception condition if one has been
   ;      encountered, or a null string otherwise.
   ;
   ;  RETURNED VALUE TYPE: INTEGER.
   ;
   ;  OUTCOME:
   ;
   ;  *   If no exception condition has been detected, this function
   ;      returns [0, or default returned value], and the output keyword
   ;      parameter excpt_cond is set to a null string, if the optional
   ;      input keyword parameter DEBUG was set and if the optional output
   ;      keyword parameter EXCPT_COND was provided in the call. The
   ;      output positional parameter contains the results generated by
   ;      this function.
   ;
   ;  *   If an exception condition has been detected, this function
   ;      returns [a non-zero error code, or some non-sandard returned
   ;      value], and the output keyword parameter excpt_cond contains a
   ;      message about the exception condition encountered, if the
   ;      optional input keyword parameter DEBUG is set and if the
   ;      optional output keyword parameter EXCPT_COND is provided. The
   ;      output positional parameter may be undefined, inexistent,
   ;      incomplete or useless.
   ;
   ;  EXCEPTION CONDITIONS:
   ;
   ;  *   Error 100: One or more positional parameter(s) are missing.
   ;
   ;  *   Error 110: The input positional parameter misr_mode is invalid.
   ;
   ;  *   Error 120: The input positional parameter misr_path is invalid.
   ;
   ;  *   Error 130: The input positional parameter misr_orbit is invalid.
   ;
   ;  *   Error 140: The input positional parameter misr_block is invalid.
   ;
   ;  *   Error 110: Input positional parameter xxx is not of type yyy.
   ;
   ;  *   Error 200: An exception condition occurred in mpocv2fn_l1b2.pro.
   ;
   ;  *   Error 210: An exception condition occurred in is_readable.pro.
   ;
   ;  *   Error 220: An exception condition occurred in the IDL routine
   ;      EOS_GD_OPEN.
   ;
   ;  *   Error 230: An exception condition occurred in the IDL routine
   ;      EOS_GD_ATTACH.
   ;
   ;  *   Error 240: An exception condition occurred in the IDL routine
   ;      EOS_GD_READFIELD.
   ;
   ;  *   Error 250: An exception condition occurred in the IDL routine
   ;      EOS_GD_DETACH.
   ;
   ;  *   Error 260: An exception condition occurred in the IDL routine
   ;      EOS_GD_CLOSE.
   ;
   ;  DEPENDENCIES:
   ;
   ;  *   chk_misr_block.pro
   ;
   ;  *   chk_misr_mode.pro
   ;
   ;  *   is_readable.pro
   ;
   ;  *   mpocv2fn_l1b2.pro
   ;
   ;  *   chk_misr_orbit.pro
   ;
   ;  *   chk_misr_path.pro
   ;
   ;  *   set_misr_specs.pro
   ;
   ;  *   strstr.pro
   ;
   ;  REMARKS:
   ;
   ;  *   NOTE 1: This function works equally well for GM and LM files.
   ;
   ;  EXAMPLES:
   ;
   ;      [Insert the command and its outcome]
   ;
   ;  REFERENCES: None.
   ;
   ;  VERSIONING:
   ;
   ;  *   2018–05–09: Version 0.9 — Initial release.
   ;
   ;  *   2018–05–10: Version 1.0 — Initial public release.
   ;
   ;  *   2018–05–18: Version 1.5 — Implement new coding standards.
   ;Sec-Lic
   ;  INTELLECTUAL PROPERTY RIGHTS
   ;
   ;  *   Copyright (C) 2017-2018 Michel M. Verstraete.
   ;
   ;      Permission is hereby granted, free of charge, to any person
   ;      obtaining a copy of this software and associated documentation
   ;      files (the “Software”), to deal in the Software without
   ;      restriction, including without limitation the rights to use,
   ;      copy, modify, merge, publish, distribute, sublicense, and/or
   ;      sell copies of the Software, and to permit persons to whom the
   ;      Software is furnished to do so, subject to the following
   ;      conditions:
   ;
   ;      The above copyright notice and this permission notice shall be
   ;      included in all copies or substantial portions of the Software.
   ;
   ;      THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
   ;      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   ;      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   ;      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   ;      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   ;      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   ;      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   ;      OTHER DEALINGS IN THE SOFTWARE.
   ;
   ;      See: https://opensource.org/licenses/MIT.
   ;
   ;  *   Feedback
   ;
   ;      Please send comments and suggestions to the author at
   ;      MMVerstraete@gmail.com.
   ;Sec-Cod

   info = SCOPE_TRACEBACK(/STRUCTURE)
   rout_name = info[N_ELEMENTS(info) - 1].ROUTINE

   ;  Initialize the default return code and the exception condition message:
   return_code = 0
   excpt_cond = ''

   ;  Set the default values of essential input keyword parameters:
   IF (KEYWORD_SET(debug)) THEN debug = 1 ELSE debug = 0
   IF (KEYWORD_SET(verbose)) THEN verbose = 1 ELSE verbose = 0

   ;  Initialize the output positional parameter(s):
   bad_struct = {}

   IF (debug) THEN BEGIN

   ;  Return to the calling routine with an error message if one or more
   ;  positional parameters are missing:
      n_reqs = 5
      IF (N_PARAMS() NE n_reqs) THEN BEGIN
         error_code = 100
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': Routine must be called with ' + strstr(n_reqs) + $
            ' positional parameter(s): misr_mode, misr_path, misr_orbit, ' + $
            'misr_block, bad_struct.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'misr_mode' is invalid:
      rc = chk_misr_mode(misr_mode, DEBUG = debug, EXCPT_COND = excpt_cond)
      IF (rc NE 0) THEN BEGIN
         error_code = 110
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': ' + excpt_cond
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'misr_path' is invalid:
      rc = chk_misr_path(misr_path, DEBUG = debug, EXCPT_COND = excpt_cond)
      IF (rc NE 0) THEN BEGIN
         error_code = 120
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': ' + excpt_cond
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'misr_orbit' is invalid:
      rc = chk_misr_orbit(misr_orbit, DEBUG = debug, EXCPT_COND = excpt_cond)
      IF (rc NE 0) THEN BEGIN
         error_code = 130
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': ' + excpt_cond
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'misr_block' is invalid:
      rc = chk_misr_block(misr_block, DEBUG = debug, EXCPT_COND = excpt_cond)
      IF (rc NE 0) THEN BEGIN
         error_code = 140
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': ' + excpt_cond
         RETURN, error_code
      ENDIF
   ENDIF

   ;  Set the number and names of the cameras and bands:
   specs = set_misr_specs()
   n_cams = specs.NCameras
   cams = specs.CameraNames
   n_bnds = specs.NBands
   bnds = specs.BandNames

   ;  Set the MISR version for now--will need to be more flexible later,
   ;  when new versions of the L1B2 files become available:
   misr_version = 'F03_0024'

   ;  Define and start populating the output structure:
   bad_struct = CREATE_STRUCT('Title', $
      'Metadata on bad data pixels for a single Block of 9 MISR L1B2 files')
   bad_struct = CREATE_STRUCT(bad_struct, 'MISR_Mode', misr_mode)
   bad_struct = CREATE_STRUCT(bad_struct, 'MISR_Path', misr_path)
   bad_struct = CREATE_STRUCT(bad_struct, 'MISR_Orbit', misr_orbit)
   bad_struct = CREATE_STRUCT(bad_struct, 'MISR_Block', misr_block)

   ;  Iterate over the cameras:
   FOR cam = 0, n_cams  - 1 DO BEGIN
      cam_name = cams[cam]
      IF (verbose) THEN PRINT, 'Start processing camera ' + cam_name + '.'

   ;  Build the filename for this camera:
      rc = mpocv2fn_l1b2(misr_mode, misr_path, misr_orbit, cam_name, $
         misr_version, l1b2_fspec, DEBUG = debug, EXCPT_COND = excpt_cond)

      IF (debug) THEN BEGIN
         IF (rc NE 0) THEN BEGIN
            error_code = 200
            excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
               ': ' + excpt_cond
            RETURN, error_code
         ENDIF

   ;  Check that this file is is_readable:
         IF (is_readable(l1b2_fspec) NE 1) THEN BEGIN
            error_code = 210
            excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
               ': ' + excpt_cond
            RETURN, error_code
         ENDIF
      ENDIF

   ;  Open the HDF file for this camera:
      fid = EOS_GD_OPEN(l1b2_fspec, /READ)
      IF ((debug) AND (fid EQ -1)) THEN BEGIN
         error_code = 220
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': An error was encountered in IDL routine EOS_GD_OPEN.'
         RETURN, error_code
      ENDIF

      FOR bnd = 0, n_bnds  - 1 DO BEGIN
         bnd_name = bnds[bnd]
         cam_bnd = cam_name + '_' + bnd_name
         IF (verbose) THEN PRINT, '   Processing band ' + cam_bnd + '.'

   ;  Set the HDF grid name and field labels:
         grid = bnd_name + 'Band'
         field = bnd_name + ' Radiance/RDQI'

         gid = EOS_GD_ATTACH(fid, grid)
         IF ((debug) AND (gid EQ -1)) THEN BEGIN
            error_code = 230
            excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
               ': An error was encountered in IDL routine EOS_GD_ATTACH.'
            RETURN, error_code
         ENDIF

   ;  Read the radiance data:
         status = EOS_GD_READFIELD(gid, field, databuf)
         IF ((debug) AND (status EQ -1)) THEN BEGIN
            error_code = 240
            excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
               ': An error was encountered in IDL routine EOS_GD_READFIELD.'
            RETURN, error_code
         ENDIF

   ;  Detach the grid and close the HDF file:
         status = EOS_GD_DETACH(gid)
         IF ((debug) AND (status EQ -1)) THEN BEGIN
            error_code = 250
            excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
               ': An error was encountered in IDL routine EOS_GD_DETACH.'
            RETURN, error_code
         ENDIF

   ;  Extract the scaled radiance data for the required Block (0-based in IDL),
   ;  where the integer division by 4 serves to remove the RDQI:
         nbadd = 0
         block_data = databuf[*, *, misr_block - 1]
         badd = WHERE(block_data EQ 65523, nbadd)

   ;  Record the number of bad pixels for this camera and band combination:
         item_name = cam_bnd + '_' + 'nbad'
         bad_struct = CREATE_STRUCT(bad_struct, item_name, nbadd)

   ;  Compute the number of pixels in the Block:
         IF ((misr_mode EQ 'LM') OR (misr_mode EQ 'GM' AND $
            ((cam_name EQ 'AN') OR (bnd_name EQ 'Red')))) THEN BEGIN
            ncols = 2048L
            nlins = 512L
         ENDIF ELSE BEGIN
            ncols = 512L
            nlins = 128L
         ENDELSE

   ;  If there are bad pixels, derive and report on their line and sample
   ;  coordinates:
         IF (nbadd GT 0) THEN BEGIN
            bad_lines = LONARR(nbadd)
            bad_sampl = LONARR(nbadd)
            FOR i = 0, nbadd - 1 DO BEGIN
               bad_lines[i] = badd[i] / ncols
               bad_sampl[i] = badd[i] MOD ncols
            ENDFOR
            item_name = cam_bnd + '_' + 'badlines'
            bad_struct = CREATE_STRUCT(bad_struct, item_name, bad_lines)
            item_name = cam_bnd + '_' + 'badsampl'
            bad_struct = CREATE_STRUCT(bad_struct, item_name, bad_sampl)
         ENDIF
      ENDFOR

      status = EOS_GD_CLOSE(fid)
      IF ((debug) AND (status EQ -1)) THEN BEGIN
         error_code = 260
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': An error was encountered in IDL routine EOS_GD_CLOSE.'
         RETURN, error_code
      ENDIF

   ENDFOR

   RETURN, return_code

END
